import os
import openai
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
import requests
from pydub import AudioSegment

user_profiles = {}
user_states = {}
user_histories = {}
user_topics = {}  # âœ… í˜„ì¬ í•™ìŠµ ì¤‘ì¸ ì£¼ì œ ì €ì¥ìš©

survey_questions = [
    ("native", "ğŸ—£ ëª¨êµ­ì–´ê°€ ë¬´ì—‡ì¸ê°€ìš”? (Your native language)?"),
    ("target", "ğŸ“˜ ë°°ìš°ê³  ì‹¶ì€ ì–¸ì–´ëŠ” ë¬´ì—‡ì¸ê°€ìš”? (Which language would you like to learn?)"),
    ("age", "ğŸ“… ë‚˜ì´ëŒ€ê°€ ì–´ë–»ê²Œ ë˜ë‚˜ìš”? (What is your age group?)"),
    ("gender", "ğŸ‘¤ ì„±ë³„ì´ ì–´ë–»ê²Œ ë˜ì‹œë‚˜ìš”? (ë‚¨ì„±/ì—¬ì„±)"),
    ("level", "ğŸ“Š í˜„ì¬ ì‹¤ë ¥ì€ ì–´ëŠì •ë„ì¸ê°€ìš”? (ì˜ˆ: ì´ˆê¸‰, ì¤‘ê¸‰, ê³ ê¸‰ ë˜ëŠ” ì„¤ëª…ìœ¼ë¡œ) (Your level: beginner/intermediate/advanced?)")
]

language_explanation = {
    "Korean": "ì„¤ëª…ì€ í•œêµ­ì–´ë¡œ í•´ì£¼ì„¸ìš”.",
    "Japanese": "èª¬æ˜ã¯æ—¥æœ¬èªã§ãŠé¡˜ã„ã—ã¾ã™ã€‚",
    "Spanish": "Explica en espaÃ±ol, por favor.",
    "Vietnamese": "Giáº£i thÃ­ch báº±ng tiáº¿ng Viá»‡t giÃºp tÃ´i.",
    "Chinese": "è¯·ç”¨ä¸­æ–‡è§£é‡Šã€‚",
    "Indonesian": "Tolong jelaskan dalam Bahasa Indonesia."
}

def get_tone(age, gender):
    if age == "20ëŒ€":
        return "í˜•" if gender == "ë‚¨ì„±" else "ì–¸ë‹ˆ"
    elif age == "30ëŒ€":
        return "í˜•" if gender == "ë‚¨ì„±" else "ì–¸ë‹ˆ"
    elif age == "40ëŒ€":
        return "í˜•ë‹˜" if gender == "ë‚¨ì„±" else "ì–¸ë‹ˆ"
    elif age == "50ëŒ€ ì´ìƒ":
        return "í˜•ë‹˜" if gender == "ë‚¨ì„±" else "ì„ ìƒë‹˜"
    return "í˜•ë‹˜"

def get_system_prompt(profile):
    explanation = language_explanation.get(profile['native'], "Explain in English.")
    tone = get_tone(profile['age'], profile['gender'])
    return f"""
You are a smart language tutor called CC4AI íŠœí„°.
The user is a {profile['age']} {profile['gender']}, native language: {profile['native']}, learning: {profile['target']}.
Explain grammar, expressions and pronunciation in a friendly way using {profile['native']}.
When the user gives a topic (e.g., computer, travel, food), ask a follow-up question to go deeper (e.g., 'coding', 'hardware').
Then, based on the subtopic, teach useful English expressions, vocabulary, and pronunciation.
Give example sentences and encourage the user to repeat them.
Then, wait for the userâ€™s voice or message.
Do not only explain the topic, always teach English based on it.
Keep the conversation flowing naturally.
"""

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_states[user_id] = 0
    user_profiles[user_id] = {}
    await update.message.reply_text("ğŸ‘‹ ì„¤ë¬¸ì„ ì‹œì‘í•©ë‹ˆë‹¤! Let's start the survey!")
    await ask_next_question(update, user_id)

async def ask_next_question(update, user_id):
    state = user_states[user_id]
    if state < len(survey_questions):
        key, question = survey_questions[state]
        await update.message.reply_text(question)
    else:
        await update.message.reply_text("âœ… ì„¤ë¬¸ ì™„ë£Œ! ì´ì œ ìˆ˜ì—…ì„ ì‹œì‘í• ê²Œìš” í˜•ë‹˜.")
        del user_states[user_id]
        await update.message.reply_text("ë¬´ìŠ¨ ì£¼ì œë¡œ ìˆ˜ì—…ì„ ì‹œì‘í•´ë³¼ê¹Œìš”?")  # í•™ìŠµì ì¤‘ì‹¬ ì‹œì‘

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    text = update.message.text.strip()

    if user_id in user_states:
        state = user_states[user_id]
        key, _ = survey_questions[state]
        user_profiles[user_id][key] = text
        user_states[user_id] += 1
        await ask_next_question(update, user_id)
    else:
        profile = user_profiles.get(user_id)
        if profile:
            await tutor_response(text, update, profile)
        else:
            await update.message.reply_text("ì²˜ìŒ ì˜¤ì…¨êµ°ìš”! ì„¤ë¬¸ë¶€í„° ì§„í–‰í• ê²Œìš” í˜•ë‹˜ ğŸ“")
            user_states[user_id] = 0
            user_profiles[user_id] = {}
            await ask_next_question(update, user_id)

async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    if user_id not in user_profiles:
        await update.message.reply_text("ì²˜ìŒ ì˜¤ì…¨êµ°ìš”! ì„¤ë¬¸ë¶€í„° ì§„í–‰í• ê²Œìš” í˜•ë‹˜ ğŸ“")
        user_states[user_id] = 0
        user_profiles[user_id] = {}
        await ask_next_question(update, user_id)
        return

    file = await context.bot.get_file(update.message.voice.file_id)
    ogg_path = "voice.ogg"
    mp3_path = "voice.mp3"
    await file.download_to_drive(ogg_path)
    AudioSegment.from_ogg(ogg_path).export(mp3_path, format="mp3")

    with open(mp3_path, "rb") as f:
        transcript = openai.audio.transcriptions.create(model="whisper-1", file=f)

    await tutor_response(transcript.text, update, user_profiles[user_id])

async def tutor_response(user_input: str, update: Update, profile: dict):
    try:
        user_id = update.effective_user.id
        system_prompt = get_system_prompt(profile)

        if user_id not in user_histories:
            user_histories[user_id] = []

        # âœ… ì£¼ì œë¥¼ ê¸°ì–µ (ì²˜ìŒ ì…ë ¥ ì‹œ)
        if user_id not in user_topics:
            user_topics[user_id] = None

        # ì£¼ì œë¥¼ ì •í•˜ì§€ ì•Šì•˜ë‹¤ë©´, ì§€ê¸ˆ ì£¼ì œë¥¼ ì €ì¥
        if user_topics[user_id] is None and len(user_input) < 20:
            user_topics[user_id] = user_input

        # GPT ëŒ€í™” íˆìŠ¤í† ë¦¬ êµ¬ì„±
        user_histories[user_id].append({"role": "user", "content": user_input})
        history = user_histories[user_id][-10:]
        messages = [{"role": "system", "content": system_prompt}] + history

        response = openai.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=messages
        )

        reply = response.choices[0].message.content
        user_histories[user_id].append({"role": "assistant", "content": reply})

        await update.message.reply_text(reply)

        speech = openai.audio.speech.create(
            model="tts-1",
            voice="nova",
            input=reply
        )
        tts_path = "response.mp3"
        with open(tts_path, "wb") as f:
            f.write(speech.content)

        await update.message.reply_voice(voice=open(tts_path, "rb"))

    except Exception as e:
        await update.message.reply_text(f"âŒ ì˜¤ë¥˜ ë°œìƒ: {str(e)}")

if __name__ == "__main__":
    openai.api_key = os.getenv("OPENAI_API_KEY")
    app = ApplicationBuilder().token(os.getenv("TELEGRAM_TOKEN")).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    app.add_handler(MessageHandler(filters.VOICE, handle_voice))
    print("âœ… CC4AI íŠœí„° ì‘ë™ ì¤‘")
    app.run_polling()
